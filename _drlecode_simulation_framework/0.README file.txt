Readme file.

	
*********************************************************************************
If you have any questions, please send an email to: Hai Le - hle30@emory.edu

The framework is written in Java.

*********************************************************************************
The main file is stored under Core/Main.java

*********************************************************************************
Unility/GlobalVariable.java stores environment specification including: 

search_Model : true - searching for models | false - running a model specification.

WorldSize_height & WorldSize_width :setting the space demension. 

duration: simulation time-steps of the simulations

burn_in_step: how long the simulation runs before evaluations begin.

Entity:
number_of_agents: number of agents for a simulation
agent_radius: agents' size
agent_speed: max speed of agents
agent_personal_space: how deep each agent can overlap each other.
fov_distance & fov_angle: how far and how wide agent can see.

Behavior:
max_behavior: maximum number of behavior a model can have
max_filter: maximum number of filters that each behavior can have

Genetic Algorithm: (GA)
num_generation: how many generations GA will run
simulation_per_generation: number of evaluations for each models.
stop_score: threshold to stop the search. (1 is the max fitness score)

*********************************************************************************
searchMethod/SearchSpace contains all possibilities that a model can have

//BELOW is all options for GA
	//
	//Type:
	//1.0 Agent (1.0 is blue, 1.1 is red)
	//2.0 Obstacle
	//3.0 Goal (3.0 is red goal, 3.1 is blue goal)
	public ArrayList<Double> entity_type = new ArrayList<Double>(Arrays.asList(1.0, 2.0, 3.0, 3.1));
	
	
	//Property
	//Apply for activation and filter
	//1.0: Position
	//2.0: Angle 
	//2.1: Angle difference between heading and heading to target agent.
	//3.0: Speed
	//4.0: Type
	//5.0: Zone
	//When add more property, check for "extract_p" keyword in the whole project
	public ArrayList<Double> properties = new ArrayList<Double>(Arrays.asList(1.0,2.0,3.0));

	//Numerical extraction property type
	public ArrayList<Double> numerical_property = new ArrayList<Double>(Arrays.asList(1.0,2.0,2.1,3.0));
	
	//Categorical extraction property type
	public ArrayList<Double> categorical_property = new ArrayList<Double>(Arrays.asList(4.0));
	
	//Behavior option
	//Option 0: get reference from self
	//Option 1: get reference from neighbor
	//Option 2: get reference from space
	public ArrayList<Integer> action_option = new ArrayList<Integer>(Arrays.asList(0,1,2));

	// 1 -> nearest_desired
	// 2 -> farthest 
	// 3 -> nearest_turning
	// 4 -> density within [-10,10]
	// 5 -> predict distance to entrance
	public ArrayList<Double> act_on_space_property = new ArrayList<Double>(Arrays.asList(1.0, 2.0 , 2.1, 2.5, 3.0));

	//Filter
	//Filter type
	//0: Ranged filter
	//1: Combination method filter
	public ArrayList<Integer> filter_type = new ArrayList<Integer>(Arrays.asList(0,1));

	//public ArrayList<Double> filter_range_property= new ArrayList<Double>(Arrays.asList(1.0,2,1,3.0,4.0));
	
	//All behavior must have one category filter
	public ArrayList<Double> filter_range_property= new ArrayList<Double>(Arrays.asList(1.0, 2.0, 2.1, 3.0,4.0));
	
	//Filter range for space behavior
	public ArrayList<Double> filter_range_property_space= new ArrayList<Double>(Arrays.asList(1.0, 2.0,2.1,2.5,3.0));

	//Method filter should not be used for category property
	//Method filter has 5 methods:
	//Nearest: 1.0, 2.0, 2.1, 3.0
	//Farthest: 1.0, 2.0, 2.1, 3.0
	//Max: 3.0
	//Min: 3.0
	//random: special case, choose any neighbor

	public ArrayList<Double> filter_method_property= new ArrayList<Double>(Arrays.asList(1.0,2.1,3.0));

	public ArrayList<Integer> filter_method= new ArrayList<Integer>(Arrays.asList(1));

	//All behavior must have one category filter
	public ArrayList<Double> filter_method_property_for_space = new ArrayList<Double>(Arrays.asList(1.0, 2.0, 3.0));

	public ArrayList<Integer> filter_method_space= new ArrayList<Integer>(Arrays.asList(1));
		
	//Activation

	//Activation weight for always activation and binary function
	public ArrayList<Double> activation_weight = new ArrayList<Double>(Arrays.asList(1.0, 5.0, 10.0, 20.0, 50.0));
	//0: Always true
	//1: self 
	//2: neighbor
	//3: space
	public ArrayList<Integer> activation_option = new ArrayList<Integer>(Arrays.asList(0,1,2,3));
	
	public ArrayList<Double> activation_self_check_properties = new ArrayList<Double>(Arrays.asList(2.0,3.0));
	
	public ArrayList<Double> activation_neighbor_check_properties = new ArrayList<Double>(Arrays.asList(1.0, 2.1,3.0));
	
	public ArrayList<Double> activation_space_check_properties = new ArrayList<Double>(Arrays.asList(1.0,2.0,2.1,2.5,3.0));
	
	//Activation function option
	//0: return weight = 1
	//1: binary funciton
	//2: linear function - does not apply for category properties
	public ArrayList<Integer> activation_function_option = new ArrayList<Integer>(Arrays.asList(1,2));
	
	public ArrayList<Double> linear_activation_function_slope = new ArrayList<Double>(Arrays.asList(1.0,5.0,10.0,50.0,100.0));
	
