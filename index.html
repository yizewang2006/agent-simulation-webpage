<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Agent Simulation Project</title>
  <!-- Include Roboto font from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <!-- I find this font good looking, including it here. -->
  <link href="https://db.onlinewebfonts.com/c/33bce88f104fedc26d91518f6d8b4ca3?family=LetoSans-Bold" rel="stylesheet">
  <!-- Highway Gothic font -->
  <link href="https://db.onlinewebfonts.com/c/734e5a726f37f261ff8a0d96260612a0?family=Highway+Gothic" rel="stylesheet" type="text/css"/>
  <!-- Probably a bunch of CSS Codes, consulted ChatGPT for this-->
  <style>
    /* Global font setting */
    body {
      font-family: 'Highway Gothic', sans-serif;
      margin: 0;
      padding: 0;
    }
  
    /* Reusable flex row container with gap */
    .row-flex {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
  
    /* Reusable input block layout */
    .input-block {
      flex: 1;
      box-sizing: border-box;
    }
  
    /* Margin top for grouped rows */
    .group-margin-top {
      margin-top: 10px;
    }
  
    /* Reusable coordinate section styles */
    .coordinate-section {
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(128,128,128,0.1);
      border-radius: 8px;
    }
  
    /* Header styling, for the title and subtitle */
    header h1,
    header h2 {
      text-align: center;
      font-family: 'Highway Gothic', sans-serif;
      font-weight: 700;
      color: #333;
      background-color: beige;
      margin: 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    header h1 {
      font-size: 5em;
      padding: 10px;
    }
    header h2 {
      font-size: 1.2em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    header h3 {
      font-size: 1em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
  
    /* Subtitle styling */
    .subtitle {
      font-size: 1.2em;
      font-weight: 300;
      color: #333;
      margin-top: 0px;
      padding: 10px 0;
    }
  
    /* Container for canvas and GUI panel */
    .container {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      width: 100%;
      background-color: beige;
      box-sizing: border-box;
      padding: 10px;
    }
  
    /* Canvas styling */
    canvas {
      background-color: #FFFFFF;
      display: block;
      margin: 10px;
      border: 4px solid black;
    }
  
    /* GUI panel styling */
    .gui-panel {
      flex: 1;
      margin: 10px;
      padding: 10px;
      border: 4px solid #333;
      background-color: #f0f0f0;
    }
  
    /* Style for subtitle' */
    .subtitle-left {
      margin: 10px 0;
      padding: 0;
      border: black;
      background-color: transparent;
    }
  
    /* Style for h2 in the gui-panel and playback-controls */
    .gui-panel h2,
    .playback-controls h2 {
      text-align: center;
      font-family: 'Highway Gothic', sans-serif;
      font-size: 3em;
      font-weight: 700;
      margin: 0 0 10px 0;
    }
  
    /* How much textboxes/elements are separated vertically in the gui panel */
    .gui-panel div {
      margin-bottom: 10px;
    }
  
    /* Label styling for both agent-controls and coordinate-display */
    .agent-controls label,
    .coordinate-display label {
      display: block;
      font-weight: bold;
      margin-bottom: 3px;
      font-size: 1.2em;
    }
  
    /* Unify the repeated styles for .agent-controls and .playback-controls */
    .agent-controls,
    .playback-controls {
      margin: 0px;
      padding: 10px;
      border: none;
      background-color: rgba(128, 128, 128, 0.1);
      border-radius: 8px;
    }
  
    /* .playback-controls gets centered text. */
    .playback-controls {
      text-align: center;
    }
  
    .playback-controls input[type="range"] {
      width: 80%;
      margin: 5px 0;
    }
  
    /* Regular Style textbox */
    input[type="text"] {
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 5px 10px;
      transition: border-color 0.3s ease-in-out, box-shadow 0.3s ease;
      width: 100%;
      box-sizing: border-box;
    }
  
    /* When focused (use try to text in this textbox), the style */
    input[type="text"]:focus {
      border-color: #66afe9;
      box-shadow: 0 0 8px rgba(102, 175, 233, 0.6);
      outline: none;
    }
  
    /* Defining button styles */
    button {
      background-color: #008CBA;
      border: none;
      color: white;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 8px;
      transition: background-color 0.3s ease;
      cursor: pointer;
    }
  
    /* Defining button styles when hovered over */
    button:hover {
      background-color: #005f73;
    }
  
    /* When a button is clicked (or active) */
    button:active {
      background-color: #003f50;
    }
  
    /* Color picker for agents */
    .color-picker {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      background-color: #ccc;
      padding: 10px;
      border-radius: 8px;
      justify-content: space-around;
    }
  
    .color-swatch {
      width: 30px;
      height: 30px;
      border-radius: 10%;
      cursor: pointer;
      border: 2px solid #fff;
      transition: border 0.3s ease;
    }
  
    .color-swatch:hover {
      border: 2px solid #333;
    }
  
    /* Center the update button within its container */
    .center-button button {
      text-align: center;
      display: flex;
      flex: 1;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }

    #popupMenu label,
    #popupMenu input {
      display: block;
      margin-top: 8px;
    }

    #popupMenu .center-button {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap; /* Allow wrapping if needed */
    }

    #popupMenu .color-picker {
      display: flex;
      flex-wrap: nowrap;
      gap: 6px;
      overflow-x: auto;
      padding: 6px 0;
    }

    #popupMenu h3 {
      margin-bottom: 10px;
    }

    #popupMenu .color-swatch {
      width: 24px;
      height: 24px;
      border: 1px solid #aaa;
      cursor: pointer;
      border-radius: 4px;
      flex-shrink: 0;
    }

    #popupMenu .center-button {
      margin-top: 12px;
      text-align: center;
    }

    #popupMenu button {
      margin: 0 5px;
    }
    /* Collapsable Header showing agent's ids*/
    .collapsible-section {
      border: none;
      border-radius: 0;
      padding: 0;
      margin-top: 15px;
    }
    /* Collapsible header button */
    .collapsible-header {
      background-color: #008CBA;
      color: white;
      cursor: pointer;
      padding: 10px;
      font-size: 1.2em;
      border: none;
      text-align: left;
      width: 100%;
      border-radius: 8px;
      transition: background-color 0.3s ease;
    }

    .collapsible-header:hover {
      background-color: #005f73;
    }

    /* The collapsible content */
    .collapsible-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }

    /* Expand when active */
    .collapsible-section.active .collapsible-content {
      max-height: none;
    }

    /* Style for individual agent entry */
    .agent-entry {
      padding: 8px 5px;
      font-size: 1.1em; /* Make the text bigger */
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: flex-start; /* Align to the left */
      align-items: center;
      gap: 10px; /* Add spacing between dot and text */
    }

    /* Dot showing color */
    .agent-color-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      margin-right: 8px;
      display: inline-block;
      border: 1px solid #333;
    }

  </style>
</head>
<body>
<header>
  <h1 class="title">Welcome to Agent Simulation</h1>
  <!-- "class" is just applying the styles defined above to this header2-->
  <h2 class="subtitle"></h2>
</header>
<!-- Wrap the canvas and the GUI panel inside a container -->
<div class="container">
  <canvas id="canvasOne" width="1000" height="1000"></canvas>
  <!-- GUI panel on the right side of the canvas -->
  <div class="gui-panel">
    <!-- Agent Selection and Creation Block, uses same style as agent-control -->
    <div class="agent-controls">
      <h2>Agent Control</h2>
      <div class="row-flex center-button">
        <button id="addSpecialAgent">Create Special Agent</button>
        <button id="addNormalAgent">Create Normal Agent</button>
      </div>
      <!-- Collapsible Section: Special Agents -->
      <div class="collapsible-section" id="specialAgentsSection">
        <button class="collapsible-header">Special Agents</button>
        <div class="collapsible-content">
          <ul id="specialAgentList" class="agent-list"></ul>
        </div>
      </div>

      <!-- Collapsible Section: Normal Agents -->
      <!--
      <div class="collapsible-section" id="normalAgentsSection">
        <button class="collapsible-header">Normal Agents</button>
        <div class="collapsible-content">
          <ul id="normalAgentList" class="agent-list"></ul>
        </div>
      </div>
    </div>
    -->

    <!-- Playback control borderless box -->
    <div class="playback-controls">
      <h2>Simulation Playback</h2>
      <input type="range" id="simulationSlider" min="0" max="100" value="0">
      <div>
        <h3>Recording</h3>
      </div>
      <div>
        <!--here for start recording & end recording-->
        <button id="startRecording">Start Recording</button>
        <button id="endRecording">End Recording</button>
      </div>
      <!--
      <div>
        <button id="playButton">Play</button>
        <button id="pauseButton">Pause</button>
      </div>
      -->
    </div>
  </div>
</div>

<!-- Popup menu for editing agent parameters -->
<div id="popupMenu" style="display: none; position: absolute; z-index: 10; background: #f0f0f0; border: 2px solid #333; border-radius: 10px; padding: 10px; width: 300px; ">
  <h3 style="margin-top: 0; text-align: center;">Edit Agent</h3>
  <label>Agent Name (Click "Update" to apply change):</label>
  <input type="text" id="agentID">
  <label>Color:</label>
  <div class="color-picker" id="popupColorPicker">
    <div class="color-swatch" data-color="#000000" style="background-color: #000000;"></div>
    <div class="color-swatch" data-color="#00FF00" style="background-color: #00FF00;"></div>
    <div class="color-swatch" data-color="#0000FF" style="background-color: #0000FF;"></div>
    <div class="color-swatch" data-color="#FFFF00" style="background-color: #FFFF00;"></div>
    <div class="color-swatch" data-color="#FF00FF" style="background-color: #FF00FF;"></div>
    <div class="color-swatch" data-color="#F5C6B3" style="background-color: #F5C6B3;"></div>
  </div>
  <label>Angle (deg):</label>
  <input type="text" id="popupAngle" placeholder="Angle">
  <label>Speed:</label>
  <input type="text" id="popupSpeed" placeholder="Speed">
  <label>FOV (deg):</label>
  <input type="text" id="popupFOV" placeholder="FOV">
  <label>FOV Radius:</label>
  <input type="text" id="popupRadius" placeholder="Radius">
  <label>X Position (JavaScript):</label>
  <input readonly type="text" id="popupX" placeholder="X">
  <label>Y Position (JavaScript):</label>
  <input readonly type="text" id="popupY" placeholder="Y">
  <div class="center-button">
    <button id="popupUpdate">Update</button>
    <button id="popupClose">Close</button>
  </div>
</div>

<!-- Canvas setup -->
<script>
  // Start of the script, defining global canvas variable
  const canvas = document.getElementById('canvasOne');
  const ctx = canvas.getContext('2d');
</script>
<script src="agent.js"></script>

<!-- Main script that uses Agent (agent simulation) -->
<script>
  // New as of 3/18: selectable agent:
  let selectedAgent = null;

  // New as of 3/20: Create agents:
  let normalAgentCount = 0; // Normal agents do not draw FOV, thus no detection happens (can be added later)
  let specialAgentCount = 0;

  // Create a testing agent
  let agentOne = new Agent(true, canvas.width * 0.12, canvas.height * 0.12, 5, 0, 0, '#F5C6B3', 100, 5 * Math.PI / 6, 0, "Agent 1");
  let agentTwo = new Agent(true, canvas.width * 0.5, canvas.height * 0.5, 5, 0, 0, '#000000', 100, 5 * Math.PI / 6, 0, "Agent 2");
  let agentThree = new Agent(true, canvas.width * 0.7, canvas.height * 0.7, 5, 0, 0, '#0000FF', 100, 5 * Math.PI / 6, 0, "Agent 100");

  // Create a list of circles.
  const agents = [];

  // Create 5 circles with random positions and velocities that use the default color '#000000'
  /*
  for (let i = 0; i < 3; i++) {
    const radius = 5;
    const x = Math.random() * (canvas.width - radius * 2) + radius;
    const y = Math.random() * (canvas.height - radius * 2) + radius;
    const dxTest = (Math.random() - 0.5) * 5;
    const dyTest = (Math.random() - 0.5) * 5;
    
    // Add a FOV radius of 100 pixels and an angle of 60 degrees (PI/3)
    agents.push(new Agent(false, x, y, radius, dxTest, dyTest, "#000000", 100, 5 * Math.PI / 6));
  }
  */

  /* Test the four corners.
  const radius = 5;
  const xPos = [
    canvas.width * 0.1,  // left
    canvas.width * 0.1,  // left
    canvas.width * 0.9,  // right
    canvas.width * 0.9   // right
  ];
  const yPos = [
    canvas.height * 0.9, // bottom
    canvas.height * 0.1, // top
    canvas.height * 0.9, // bottom
    canvas.height * 0.1  // top
  ];

  const dxTest = 0;
  const dyTest = 0;

  for (let j = 0; j < 4; j++) {
    const x = xPos[j];
    const y = yPos[j];
    console.log("Creating agent", j, "at x:", x, "y:", y);

    agents.push(new Agent(false, x, y, radius, dxTest, dyTest, "#000000", 100, 5 * Math.PI / 6));
  }
  */

  agents.push(agentOne);
  agents.push(agentTwo);
  agents.push(agentThree);

  // recording
  let isRecording = false;
  let recordedFrames = []; // list holding them. 
  
  // Populate exisiting agents
  const specialList = document.getElementById('specialAgentList');
  const specialSection = document.getElementById('specialAgentsSection');

  // Helper to add agent entry to a list
  function addAgentToList(agent, listElement) {
    const li = document.createElement('li');
    li.className = 'agent-entry';

    const colorDot = document.createElement('span');
    colorDot.className = 'agent-color-dot';
    colorDot.style.backgroundColor = agent.colorHex;

    const textSpan = document.createElement('span');
    textSpan.textContent = agent.id;

    li.appendChild(colorDot);
    li.appendChild(textSpan);
    listElement.appendChild(li);
  }
  // Set 'expanded' at the beginning
  specialSection.classList.add('active');

  agents.forEach(agent => {
    if (!agent.drawFOV) return;
    addAgentToList(agent, specialList);
  });
  
  // Set speed to 0
  agentOne.dy = 0;
  agentOne.dx = 0;

  // Add event listeners for dragging agents
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };

  // Registering mouse events
  canvas.addEventListener('mousedown', handleCanvasMouseDown);
  canvas.addEventListener('mousemove', handleCanvasMouseMove);
  canvas.addEventListener('mouseup', stopDragging);
  canvas.addEventListener('mouseleave', stopDragging);

  // Handle mouse down event to select an agent
  function handleCanvasMouseDown(e) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    isDragging = false;
    selectedAgent = null;

    for (let agent of agents) {
      const dist = Math.sqrt(
        (mouseX - agent.position.x) ** 2 + (mouseY - agent.position.y) ** 2
      );

      if (dist <= agent.radius * 2) {
        selectAgent(agent, mouseX, mouseY);
        break;
      }
    }
  }

  // Handle mouse move event to drag the selected agent
  function handleCanvasMouseMove(e) {
    if (!isDragging || !selectedAgent) return;

    document.getElementById('popupMenu').style.display = 'none';

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    let newX = mouseX + dragOffset.x;
    let newY = mouseY + dragOffset.y;

    newX = Math.max(selectedAgent.radius, Math.min(newX, canvas.width - selectedAgent.radius));
    newY = Math.max(selectedAgent.radius, Math.min(newY, canvas.height - selectedAgent.radius));

    selectedAgent.position.x = newX;
    selectedAgent.position.y = newY;
  }

  // Stop dragging when mouse is released or leaves the canvas
  function stopDragging() {
    isDragging = false;
  }

  // Select an agent and show the popup with its current data
  function selectAgent(agent, mouseX, mouseY) {
    selectedAgent = agent;
    dragOffset.x = agent.position.x - mouseX;
    dragOffset.y = agent.position.y - mouseY;
    isDragging = true;

    const popup = document.getElementById('popupMenu');
    popup.style.left = `${agent.position.x + 100}px`;
    popup.style.top = `${agent.position.y + 100}px`;
    popup.style.display = 'block';

    highlightSelectedSwatch(agent.colorHex);

    document.getElementById('agentID').value = agent.id;
    document.getElementById('popupAngle').value = (-agent.angle * 180 / Math.PI).toFixed(2);
    document.getElementById('popupSpeed').value = Math.sqrt(agent.dx ** 2 + agent.dy ** 2).toFixed(2);
    document.getElementById('popupFOV').value = (agent.fovAngle * 180 / Math.PI).toFixed(2);
    document.getElementById('popupRadius').value = agent.fovRadius.toFixed(2);
    document.getElementById('popupX').value = agent.position.x.toFixed(2);
    document.getElementById('popupY').value = agent.position.y.toFixed(2);
  }

  function highlightSelectedSwatch(colorHex) {
    swatches.forEach(swatch => {
      const swatchColor = swatch.getAttribute('data-color');
      swatch.style.border = (swatchColor === colorHex) ? '2px solid #333' : '2px solid #fff';
    });
  }

  // --- Below are UI controls ---
  // Get all color swatches
  const swatches = document.querySelectorAll('.color-swatch'); // Find all 'color-swatches'
  swatches.forEach(swatch => {
    swatch.addEventListener('click', function() {
      const color = this.getAttribute('data-color');
      if (selectedAgent) {
        selectedAgent.colorHex = color;
        selectedAgent.originalColor = color; // Previously, by exiting other agent's FOV, it will return to black. By setting original color to selected color, we avoid this issue.
      }
      highlightSelectedSwatch(color); // Highlight UI part
    });
  });

  // Update via pop-up menu.
  document.getElementById('popupUpdate').addEventListener('click', () => {
    if (!selectedAgent) return;

    const degToRad = d => d * Math.PI / 180;

    selectedAgent.id = document.getElementById('agentID').value;
    selectedAgent.angle = -degToRad(parseFloat(document.getElementById('popupAngle').value));
    const spd = parseFloat(document.getElementById('popupSpeed').value);
    selectedAgent.dx = spd * Math.cos(selectedAgent.angle);
    selectedAgent.dy = spd * Math.sin(selectedAgent.angle);
    selectedAgent.fovAngle = degToRad(parseFloat(document.getElementById('popupFOV').value));
    selectedAgent.fovRadius = parseFloat(document.getElementById('popupRadius').value);
    selectedAgent.position.x = parseFloat(document.getElementById('popupX').value);
    selectedAgent.position.y = parseFloat(document.getElementById('popupY').value);
  });
  
  document.getElementById('popupClose').addEventListener('click', () => {
    document.getElementById('popupMenu').style.display = 'none'; // Close the popup menu
  });

  // Random agent parameter generator function
  function randomParameter() {
    const radius = 5;

    const x = Math.random() * (canvas.width - 2 * radius) + radius;
    const y = Math.random() * (canvas.height - 2 * radius) + radius;
    const dx = (Math.random() - 0.5) * 4;
    const dy = (Math.random() - 0.5) * 4;
    const angle = Math.atan2(dy, dx);

    return { x, y, dx, dy, angle, radius };
  }


  // Wire function to createNormalAgent button.
  document.getElementById("addNormalAgent").addEventListener("click", () => {
    normalAgentCount++;
    const name = `Normal Agent ${normalAgentCount}`;

    const { x, y, dx, dy, angle, radius } = randomParameter();

    const agent = new Agent(false, x, y, radius, dx, dy, '#000000', 100, 5 * Math.PI / 6, angle, name);

    agents.push(agent);

    // Add to the DOM list
    const list = document.getElementById('normalAgentList');

    const li = document.createElement('li');
    li.className = 'agent-entry';

    // Create a colored dot
    const colorDot = document.createElement('span');
    colorDot.className = 'agent-color-dot';
    colorDot.style.backgroundColor = agent.colorHex;

    // Create the text span
    const textSpan = document.createElement('span');
    textSpan.textContent = name;

    // Combine and append
    li.appendChild(colorDot);
    li.appendChild(textSpan);
    list.appendChild(li);
  });

  // Wire function to createSpecialAgent button.
  document.getElementById("addSpecialAgent").addEventListener("click", () => {
    specialAgentCount++;
    const name = `Special Agent ${specialAgentCount}`;
    const { x, y, dx, dy, angle, radius } = randomParameter();
    // Create a special agent — set isSpecial to true
    const agent = new Agent(true, x, y, radius, dx, dy, '#F5C6B3', 100, 5 * Math.PI / 6, angle, name);

    agents.push(agent);
    // Add to the DOM list
    const list = document.getElementById('specialAgentList');

    const li = document.createElement('li');
    li.className = 'agent-entry';

    // Create a colored dot
    const colorDot = document.createElement('span');
    colorDot.className = 'agent-color-dot';
    colorDot.style.backgroundColor = agent.colorHex;

    // Create the text span
    const textSpan = document.createElement('span');
    textSpan.textContent = name;

    // Combine and append
    li.appendChild(colorDot);
    li.appendChild(textSpan);
    list.appendChild(li);
  });

  // Setup collapsible headers
  document.querySelectorAll('.collapsible-header').forEach(header => {
    header.addEventListener('click', function () {
      const section = this.parentElement;
      section.classList.toggle('active');
    });
  });
  
  // Recording functions
  function startRecording() {
    isRecording = true;
    recordedFrames = [];
    console.log("Recording in progress");
  }

  function endRecording() {
    isRecording = false;
    console.log("Recording stopped. This recording has " + recordedFrames.length + " frames.");
    console.log("results: recordedFrames");
    console.table(recordedFrames[recordedFrames.length - 1]); // showing last frame
    // registering slider event
    const slider = document.getElementById("simulationSlider");
    slider.max = recordedFrames.length - 1; // index goes from 0..N-1
    slider.value = 0; // reset to start
  }

  function showFrame(frameIndex) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!recordedFrames[frameIndex]) return;

    recordedFrames[frameIndex].forEach(info => {
      // Draw an agent from saved info
      ctx.beginPath();
      ctx.arc(info.x, info.y, 5, 0, Math.PI * 2);
      ctx.fillStyle = info.color;
      ctx.fill();
      ctx.closePath();
    });
  }

  //!needs attention: all agents continues with their path and motions even when we replay
  document.getElementById("startRecording").addEventListener("click", startRecording);
  document.getElementById("endRecording").addEventListener("click", endRecording);
  document.getElementById("simulationSlider").addEventListener("input", (e) => {
    const frameIndex = parseInt(e.target.value, 10);
    showFrame(frameIndex);
  });

  // have 3 slots & 1 save button, pick 1 and play in a new window. when user clicks 'replay' function keys, must record positions of all agents at that moment.

  function updateGUI() {
    // If no agent is selected, exit function
    if (!selectedAgent) return;
    // Calculate Cartesian coordinates with the desired range.
    // For X: subtract half the canvas width, then multiply by 2.
    let cartesianX = ((selectedAgent.position.x - canvas.width / 2) * 2).toFixed(2);
    // For Y: subtract the canvas y from half the canvas height (to flip the axis),
    // then multiply by 2.
    let cartesianY = ((canvas.height / 2 - selectedAgent.position.y) * 2).toFixed(2);
    
    // Update JavaScript coordinates (raw canvas coordinates)
    document.getElementById('popupX').value = selectedAgent.position.x.toFixed(2);
    document.getElementById('popupY').value = selectedAgent.position.y.toFixed(2);

    // Sync other fields when selecting an agent
    /*
    document.getElementById('popupAngle').value = (-selectedAgent.angle * 180 / Math.PI).toFixed(2);
    const speed = Math.sqrt(selectedAgent.dx ** 2 + selectedAgent.dy ** 2).toFixed(2);
    document.getElementById('popupSpeed').value = speed;
    document.getElementById('popupFOV').value = (selectedAgent.fovAngle * 180 / Math.PI).toFixed(2);
    document.getElementById('popupRadius').value = selectedAgent.fovRadius.toFixed(2);
    */

    //console.log(selectedAgent);
  }

  /*
  // Attach the generateRandomColor event listener once
  document.getElementById('generateRandomColor').addEventListener('click', function() {
    agentOne.generateRandomColor();
    document.getElementById('agentColor').value = agentOne.colorHex; // Update the color hexcode in the textbox
  });
  */

  /* This function is commented out because reset agent no longer exists.
  document.getElementById('resetAgent').addEventListener('click', function() {
  if (!selectedAgent) return;

  selectedAgent.angle = 0;
  selectedAgent.dx = 0;
  selectedAgent.dy = 0;
  selectedAgent.fovAngle = 5 * Math.PI / 6;
  selectedAgent.fovRadius = 100;

  document.getElementById('agentAngle').value = 0;
  document.getElementById('agentSpeed').value = 0;
  document.getElementById('agentFOV').value = 150;
  document.getElementById('agentFOVRadius').value = 100;
  });
  */

  // Update agents
  document.getElementById('popupUpdate').addEventListener('click', function() {
  if (!selectedAgent) return;

    function degreesToRadians(deg) {
      return deg * Math.PI / 180;
    }

    const angleDeg = parseFloat(document.getElementById('popupAngle').value);
    if (!isNaN(angleDeg)) {
      const angleRad = -degreesToRadians(angleDeg);
      selectedAgent.angle = angleRad;
    }

    const speed = parseFloat(document.getElementById('popupSpeed').value);
    if (!isNaN(speed)) {
      selectedAgent.dx = speed * Math.cos(selectedAgent.angle);
      selectedAgent.dy = speed * Math.sin(selectedAgent.angle);
    }

    const fovDeg = parseFloat(document.getElementById('popupFOV').value);
    if (!isNaN(fovDeg)) {
      selectedAgent.fovAngle = degreesToRadians(fovDeg);
    }

    const fovRadius = parseFloat(document.getElementById('popupRadius').value);
    if (!isNaN(fovRadius)) {
      if (fovRadius < 0) {
        alert("Warning: FOV radius must be a positive value.");
        selectedAgent.fovRadius = 100;
      } else {
        selectedAgent.fovRadius = fovRadius;
      }
    }
  });

  // Periodically update the GUI fields with selected agent's position
  setInterval(updateGUI, 1); // less number = better.

  // Animation function that updates and draws all circles.
  function animate() {
    // Clear the canvas once per frame.
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update position and redraw each circle.
    setInterval(() => {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update and draw agents
    agents.forEach(agent => agent.updatePosition(agents));

    // recording
    if (isRecording) {
      // For this frame, gather each agent's info
      const frameSnapshot = agents.map(agent => agent.reportInformation());
      recordedFrames.push(frameSnapshot);
    }
    }, 1000 / 40); // The number represents controls the framerate. 
  }

  // Start the animation loop.
  animate();
</script>

</body>
</html>